[toc]

# Leetcode 948. 令牌放置

## 问题描述

[948. 令牌放置 - 力扣（LeetCode）](https://leetcode-cn.com/problems/bag-of-tokens/)

你的初始 **能量** 为 `P`，初始 **分数** 为 `0`，只有一包令牌 `tokens` 。其中 `tokens[i]` 是第 `i` 个令牌的值（下标从 0 开始）。

令牌可能的两种使用方法如下：

*   如果你至少有 `token[i]` 点 **能量** ，可以将令牌 `i` 置为正面朝上，失去 `token[i]` 点 **能量** ，并得到 `1` **分** 。
*   如果我们至少有 `1` **分** ，可以将令牌 `i` 置为反面朝上，获得 `token[i]` 点 **能量** ，并失去 `1` **分** 。

每个令牌 **最多** 只能使用一次，使用 **顺序不限** ，**不需** 使用所有令牌。

在使用任意数量的令牌后，返回我们可以得到的最大 **分数** 。

**示例 1：**

**输入：**tokens = \[100\], P = 50
**输出：**0
**解释：**无法使用唯一的令牌，因为能量和分数都太少了。

**示例 2：**

**输入：**tokens = \[100,200\], P = 150
**输出：**1
**解释：**令牌 0 正面朝上，能量变为 50，分数变为 1 。不必使用令牌 1 ，因为你无法使用它来提高分数。

**示例 3：**

**输入：**tokens = \[100,200,300,400\], P = 200
**输出：**2
**解释：**按下面顺序使用令牌可以得到 2 分：
1. 令牌 0 正面朝上，能量变为 100 ，分数变为 1
2. 令牌 3 正面朝下，能量变为 500 ，分数变为 0
3. 令牌 1 正面朝上，能量变为 300 ，分数变为 1
4. 令牌 2 正面朝上，能量变为 0 ，分数变为 2

**提示：**

*   `0 <= tokens.length <= 1000`
*   `0 <= tokens[i], P < 104`

## 算法

### 解法1: 贪心

首先，token 可以用来让 score 增加，P 减少；也可以让 score 减少，P 增加。

而我们的目标是 score 最大。由于 score 增加需要耗费 P，因此为了让 score 尽可能大，我们要选尽可能小的 token 来让 score 增加。

当 P 不足以翻牌时，可以考虑减少 score 让 P 增加，我们这次选择尽可能大的 token 来让 P 增加。

这样，过程就出来了。

1. 首先，对 token 进行排序，我们用头部的 token 来让 score 增加，我们用尾部的 token 来让 P 增加。
2. 当我们能够将令牌翻到正面时，我们就尽可能将令牌翻到正面，直到 a. 没有令牌可反 b. P 不足以翻令牌
3. 当 P 不足以翻令牌时，我们考虑将此时没有使用的最大的 token 翻到正面来增加 P。

#### 解法1: 实现：python


```
class Solution:
    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:
        tokens.sort()
        n = len(tokens)
        i, j = 0, n - 1
        score = 0
        ret = 0
        while i <= j:
            while i <= j and tokens[i] <= P: # 有牌可翻且能量够，就一直翻牌
                score += 1
                P -= tokens[i]
                i += 1
            ret = max(ret, score)
            # i > j or tokens[i] > P
            if i > j: break # 无牌可翻
            if score > 0: # 最大的令牌翻到正面
                score -= 1
                P += tokens[j]
                j -= 1
            else:
                break
        return ret
```